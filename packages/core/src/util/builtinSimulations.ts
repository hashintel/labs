/*
The simulations are stored in the 'example_simulations' folder.
We'll need a tool that converts them into json blobs, suitable for opening in the frontend.
For the moment, it can be a one-off and the blobs can be pasted here.
Ideally, they'll either
  a) live in github and get pulled in from there.  This file can then be reduced to only holding their metadata.
  b) less ideally, be built by webpack and placed in a file that can be loaded up here.

  For now, here's wildfires.
*/

import {
  RemoteSimulationProject,
  SimulationProjectWithHcFiles,
} from "../features/project/types";
import { toHcConfig } from "../features/project/utils";
import { toHcFiles } from "../features/files/utils";

const remoteSimulationProjects: RemoteSimulationProject[] = [
  {
    id: "@hash/wildfires-regrowth",
    name: "Wildfires - Regrowth",
    description:
      "This model simulates the spread of wildfires in a regrowing forest.",
    image: null,
    thumbnail:
      "https://s3.amazonaws.com/images.hash.ai/projects/projects/hash/wildfires-regrowth/1604676092745-thumb.png",
    createdAt: "2019-12-02T15:55:46.405Z",
    updatedAt: "2022-05-19T13:57:26.000Z",
    canUserEdit: true,
    pathWithNamespace: "@hash/wildfires-regrowth",
    namespace: "hash",
    type: "Simulation",
    ref: "main",
    visibility: "public",
    ownerType: "Org",
    forkOf: null,
    license: {
      id: "5dc3da73cc0cf804dcc66a51",
      name: "MIT License",
    },
    keywords: [
      "forest",
      "fire",
      "fractal",
      "collapse",
      "climate & environment",
      "examples",
    ],
    files: [
      {
        name: "README.md",
        path: "README.md",
        contents:
          "This model simulates the spread of wildfires in a regrowing forest.\n\nAll trees grow over time, and have a small chance of being struck by lightning. If a tree is struck by lightning, or is adjacent to a fire, it sets alight. After burning for one step, the tree is reduced to an 'ember'.\n\nEmbers have a small chance of regrowing into a new tree each step, and that chance increases linearly with the count of its adjacent trees.\n\n# Analysis\n\nIn this model, we can play with the effects of changing forest density, regrowth rate, and lighting probability in order to observe the health of our 'regrowing' forest.\n\nConsider what metrics we might evaluate to determine the health of our forest:\nAverage tree height and the number of trees in our forest exhibit periodic fluctuations. We could assess the frequency of these fluctuations or their amplitude.\n\nIf we define a \"wildfire\" as a step in the model during which there are more than a certain critical percentage of trees on fire, we can assess the frequency with which they occur. Is it periodic, or does the time between them increase?\n\n## Optimization\nLet's find out what the optimal parameters are for our forest. We'll define the healthiest forest as the one with the most trees and/or trees living the longest. We can use the `sum_age` metric as a proxy for this, since it will capture both forests with lots of trees, and forests with very old trees.\n\nIf we use `sum_age` in an Optimization experiment, we might have an experiment that looks like **Optimal Rates for Forest Growth**. This optimization varies the `lightningChance` and `regrowthChance` globals to find optimal values for both of those. If we run the experiment, our result will show that we want to minimize both values.\n\nReducing the number of lightning strikes is a fairly intuitive way to increase the health of our forest, but why should we be minimizing the chance of regrowth? Well, if you observe the **Agents by behaviors** plot, you'll see that our optimal case produces very little of the wild oscillation that is found in the base set of parameters for the model. When trees become overcrowded, fires are much easier to spread, causing much more devastation, leading to the oscillating behavior. Reducing the regrowth ensures that trees lead long and healthy lives. \n\nSee also the unbounded [Forest](https://hash.ai/index/5e065650196c3fbd41d8bd43/forest) model.\n\n```video\nhttps://cdn-us1.hash.ai/site/forest-regrowth-poly.mp4\n```",
        ref: "9.9.0",
      },
      {
        name: "dependencies.json",
        path: "dependencies.json",
        contents: '{\n  "@hash/age/age.rs": "1.0.0"\n}',
        ref: "9.9.0",
      },
      {
        name: "experiments.json",
        path: "experiments.json",
        contents:
          '{\n  "Optimal Rates for Forest Growth": {\n    "type": "optimization",\n    "maxRuns": 20,\n    "minSteps": 400,\n    "maxSteps": 500,\n    "metricName": "sum_age",\n    "metricObjective": "max",\n    "fields": [\n      {"name": "regrowthChance", "range": "0.0001-0.01"},\n      {"name": "lightningChance", "range": "0.0001-0.01"}\n    ]\n  },\n  "Test Experiment": {\n    "type": "values",\n    "steps": 100,\n    "field": "lightningChance",\n    "values": [0.1, 0.01, 0.001]\n  },\n  "lightningChanceLinSpace": {\n    "steps": 100,\n    "type": "linspace",\n    "field": "lightningChance",\n    "start": 0.001,\n    "stop": 0.1,\n    "samples": 5\n  }\n}',
        ref: "9.9.0",
      },
      {
        name: "hash.json",
        path: "hash.json",
        contents:
          '{\n  "keywords": [\n    "forest",\n    "fire",\n    "fractal",\n    "collapse",\n    "climate & environment",\n    "examples"\n  ],\n  "subject": [],\n  "license": "5dc3da73cc0cf804dcc66a51",\n  "type": "Simulation",\n  "avatar": "https://s3.amazonaws.com/images.hash.ai/projects/hash/wildfires-regrowth/1604676084572-avatar.mp4",\n  "thumbnail": "https://s3.amazonaws.com/images.hash.ai/projects/projects/hash/wildfires-regrowth/1604676092745-thumb.png",\n  "files": []\n}',
        ref: "9.9.0",
      },
      {
        name: "ember.js",
        path: "src/behaviors/ember.js",
        contents:
          '/**\n * This behavior causes the agent to change from an ember\n * back to a growing tree.\n */\nfunction behavior(state, context) {\n  const { emberColor, emberHeight, regrowthChance } = context.globals();\n  \n  // Get neighbors that are "trees"\n  const forestNeighbors = context.neighbors()\n    .filter(({behaviors}) => behaviors.includes("forest.js"));\n\n  // Turn back into a tree, with a linear increase\n  // in likelihood with # of neighbors\n  const modRegrowthChance = regrowthChance * (forestNeighbors.length + 1);\n  if (modRegrowthChance > Math.random()) {\n    // Replace the ember behavior with forest behavior\n    state.behaviors[state.behaviorIndex()] = "forest.js";\n  }\n\n  // Set other needed properties for an "ember"\n  state.color = emberColor;\n  state.height = emberHeight;\n  state.age = 0;\n};\n',
        ref: "9.9.0",
      },
      {
        name: "ember.js.json",
        path: "src/behaviors/ember.js.json",
        contents:
          '{\n\t"keys": {\n\t\t"age": {\n\t\t\t"type": "number",\n\t\t\t"nullable": true\n\t\t}\n\t},\n\t"built_in_key_use": null\n}',
        ref: "9.9.0",
      },
      {
        name: "fire.js",
        path: "src/behaviors/fire.js",
        contents:
          '/**\n * This behavior causes the tree agent to "catch fire",\n * turn red, and then "burn down" into an ember.\n */\nfunction behavior(state, context) {\n\n  // Replace the fire behavior with the ember behavior\n  state.behaviors[state.behaviorIndex()] = "ember.js";\n\n  state.color = context.globals().fireColor;\n  state.shape = "fire";\n  state.height = 3;\n};\n',
        ref: "9.9.0",
      },
      {
        name: "fire.js.json",
        path: "src/behaviors/fire.js.json",
        contents: '{\n\t"keys": {},\n\t"built_in_key_use": null\n}',
        ref: "9.9.0",
      },
      {
        name: "forest.js",
        path: "src/behaviors/forest.js",
        contents:
          '/**\n * This behavior causes a tree to catch fire from its\n * neighbors or from a random lightning strike.\n */\nfunction behavior(state, context) {\n  const { lightningChance, lightningColor, \n    forestColor, forestHeight } = context.globals();\n\n  // Grow the trees\' height logarithmically with age\n  state.height = Math.max(2, 2 + Math.log2((forestHeight * state.age) / 10));\n\n\n  // Get neighbors that are on fire\n  const fireNeighbors = context.neighbors()\n    .filter(({behaviors}) => behaviors.includes("fire.js")).length;\n  \n  // Tres can be struck by lightning randomly\n  const struckByLightning = lightningChance > Math.random();\n\n  // If there is an adjacent fire or lightning strike\n  // then this tree starts to burn (becomes fire)\n  if (struckByLightning || fireNeighbors > 0) {\n    // Replace forest behavior with fire\n    state.behaviors[state.behaviorIndex()] = "fire.js";\n  }\n\n  // Color the agent appropriately\n  if (struckByLightning) {\n    state.color = lightningColor;\n  } else {\n    state.color = forestColor;\n    state.shape = "xmas-tree";\n  }\n};\n',
        ref: "9.9.0",
      },
      {
        name: "forest.js.json",
        path: "src/behaviors/forest.js.json",
        contents:
          '{\n\t"keys": {\n\t\t"age": {\n\t\t\t"type": "number",\n\t\t\t"nullable": true\n\t\t}\n\t},\n\t"built_in_key_use": null\n}',
        ref: "9.9.0",
      },
      {
        name: "globals.json",
        path: "src/globals.json",
        contents:
          '{\n  "lightningChance": 0.001,\n  "regrowthChance": 0.001,\n  "forestColor": "green",\n  "fireColor": "red",\n  "emberColor": "yellow",\n  "lightningColor": "silver",\n  "forestHeight": 10,\n  "emberHeight": 0,\n  "wildfire_count": 20,\n  "topology": {\n    "x_bounds": [-20, 20],\n    "y_bounds": [-20, 20],\n    "search_radius": 1\n  }\n}',
        ref: "9.9.0",
      },
      {
        name: "init.js",
        path: "src/init.js",
        contents:
          '/**\n * @param {InitContext} context for initialization\n */\nconst init = (context) => {\n\n  const gen_tree = () => ({\n    "behaviors": [\n      "forest.js",\n      "@hash/age/age.rs"\n    ],\n    "color": "green",\n    "shape": "xmas-tree",\n    "scale": [2, 2],\n    "height": 1\n  });\n\n  return hstd.init.grid(context.globals().topology, gen_tree);\n}\n',
        ref: "9.9.0",
      },
      {
        name: "analysis.json",
        path: "views/analysis.json",
        contents:
          '{\n  "outputs": {\n    "trees": [\n      {"op": "filter", "field": "color", "comparison": "eq", "value": "green"},\n      {"op": "count"}\n    ],\n    "fires": [\n      {"op": "filter", "field": "color", "comparison": "eq", "value": "red"},\n      {"op": "count"}\n    ],\n    "embers": [\n      {"op": "filter", "field": "color", "comparison": "eq", "value": "yellow"},\n      {"op": "count"}\n    ],\n    "forest_fire": [\n      {"op": "filter", "field": "color", "comparison": "eq", "value": "red"},\n      {"op": "count"}\n    ],\n    "age": [\n      {"op": "filter", "field": "color", "comparison": "eq", "value": "green"},\n      {"op": "get", "field": "age"},\n      {"op": "mean"}\n    ],\n    "sum_age": [\n      {"op": "filter", "field": "color", "comparison": "eq", "value": "green"},\n      {"op": "get", "field": "age"},\n      {"op": "sum"}\n    ]\n  },\n  "plots": [\n    {\n      "title": "Agents by behaviors",\n      "timeseries": ["trees", "fires", "embers"],\n      "layout": {"width": "100%", "height": "60%"},\n      "position": {"x": "0%", "y": "0%"}\n    },\n    {\n      "title": "Average age",\n      "timeseries": ["age"],\n      "layout": {"width": "100%", "height": "60%"},\n      "position": {"x": "0%", "y": "60%"}\n    },\n    {\n      "title": "Wildfire Occurrences",\n      "timeseries": ["forest_fire"],\n      "layout": {"width": "100%", "height": "60%"},\n      "position": {"x": "0%", "y": "120%"}\n    },\n    {\n      "title": "Age Distribution",\n      "type": "box",\n      "data": [{"y": "Age", "name": "Age"}],\n      "layout": {"width": "100%", "height": "50%"},\n      "position": {"x": "0%", "y": "180%"}\n    },\n    {\n      "title": "Correlation Between Trees and Fires",\n      "type": "scatter",\n      "data": [{"y": "fires", "x": "trees"}],\n      "layout": {"width": "100%", "height": "50%"},\n      "position": {"x": "0%", "y": "230%"}\n    }\n  ]\n}',
        ref: "9.9.0",
      },
    ],
    dependencies: [
      {
        pathWithNamespace: "@hash/age",
        tag: "1.0.0",
        latestReleaseTag: "1.0.0",
        canUserEdit: false,
        visibility: "public",
        files: [
          {
            name: "age.rs",
            path: "src/behaviors/age.rs",
            dependencyPath: "@hash/age/age.rs",
            contents:
              'use crate::prelude::{AgentState, Context, SimulationResult};\n\npub fn age(mut state: AgentState, _context: &Context) -> SimulationResult<AgentState> {\n    let age = match state["age"].as_i64() {\n        Some(age) => age + 1,\n        None => 1,\n    };\n\n    state["age"] = json!(age);\n\n    Ok(state)\n}\n',
            ref: "1.0.0",
          },
          {
            name: "age.rs.json",
            path: "src/behaviors/age.rs.json",
            dependencyPath: "@hash/age/age.rs.json",
            contents:
              '{\n    "keys": {\n        "age": {\n            "type": "number",\n            "nullable": true\n        }\n    },\n    "built_in_key_use": {"selected": []}\n}\n',
            ref: "1.0.0",
          },
        ],
      },
    ],
  },
  {
    id: "consensus-algorithms",
    name: "consensus-algorithms",
    description: "",
    image: null,
    thumbnail: null,
    createdAt: "2025-07-26T15:19:17.174Z",
    updatedAt: "2025-07-26T15:19:17.174Z",
    canUserEdit: true,
    pathWithNamespace: "@imported/consensus-algorithms",
    namespace: "@imported",
    type: "Simulation",
    ref: "main",
    visibility: "public",
    ownerType: "User",
    forkOf: null,
    latestRelease: null,
    license: {
      id: "5dc3da73cc0cf804dcc66a51",
      name: "MIT License",
    },
    keywords: [],
    files: [
      {
        name: "README.md",
        path: "README.md",
        contents:
          '# Simulation of fault-tolerant consensus algorithms in Hash\n\nThis is a simulator for consensus algorithms. This project is tied to the Bachelor-Thesis of Roy Adler at the Technical University Berlin 2022 named "Simulation fehlertoleranter Konsensalgorithmen in Hash" (Simulation of fault-tolerant consensus algorithms in Hash). It can be found under the link:  https://www.overleaf.com/read/sygqyrpcscfn\n\n3 different Algorithms were implemented:\n\n- Multi-Ben-Or,\n- Multi-Paxos and\n- Multi-Raft.\n\nAll algorithms are based on their original ones named without the ~~Multi~~ prefix. The changes were made to make the algorithms comparable with each other.\n\n## Functional parameters\nThe Simulation will change based on the different values in the globals.json. The following list will give an overview of all the parameters:\n\n##### algorithm\nchooses algorithm to simulate.\n\n\t 0: Multi-Ben-Or\n\t 1: Multi-Paxos\n\t 2: Multi-Raft\n\t 3: Distribution Test Program for messageMaxDelay\n\n##### numberOfAgents\ndefines number of agents in a simulation.\n\n\tnatural number\n\n##### f\nsetups fault-taulerance of Multi-Ben-Or.\n\n\tnatural number\n\n##### valueListSize\nlength of the intput list (and therefore output list) for each agent\n\n\tnatural number\n##### valueIntervalSize\nInput/Output value interval is between **[0, valueIntervalSize]**, but restriction of this work is binary consensus, so it is normally set to 2.\n\n\tnatural number\n\tstandard: 2 (binary consensus)\n\n##### acceptanceThreshold\ndecides how many faulty agents the gamemaster will tolerate, until it finishes a simulation\n\n\t natural number\n\n### agent failure\n\n##### agentDeaths\ndefines the agent failures in string format: \n\n\tagentID1,Value1;agentID2,Value2;...agentIDn,Valuen (agentID, Value are natural numbers)\n##### deathByStepOrRound\ninterpretation of value in **agentDeaths**.\n\n\tstep: value means the simulation step, where the agent failes\n\tround: value means the global round, where the agent failes\n\n##### randomDyingPercentage\npercentage with wich an agent can die in a step\n\n\treal number between 0 and 100\n\n##### messageListRandomized\nwhen the same messages being recieved in the same step for different agents, the order of messages is the same for every agent. If messageListRandomized is **true**, it shuffles the recieved messageList to simulate a different order the messages where recieved. It has the biggest effect on ***Multi-Ben-Or***, simulated with **messageMaxDelay = 0**.\n\n\tbinary\n\n##### seed\nseed for pseudonumbergeneration.\n\n\tstring\n\n##### randomScale\nrange of numbers generated by **random** function (pseudoNumberGenerator).\n\n\tnatural number\n\n##### delayFunction\ndefines the distribution function (used by **getMessageDelay(x)** function in *init.js*).\n\n\tlin: uniform distribution\n\tlog: logarithmic distribution\n\texp: exponential distribution\n\tgaus: normal distribution\n\n##### messageMaxDelay\nsets the maximum delay of a message agent.\n\n\t natural number\n\n##### g\nparameter to change the compression of the normal distribution compression.\n\n\treal number\n\n##### timeoutConstant\nFor **Multi-Paxos** and **Multi-Raft** timeouts of agents are being set in the *init.js* depending on **messageMaxDelay** and **timeoutConstant**.\nThe constant adds (or subtracts) every agent the same absolute delay. This helps for some simulations where timeout isn\'t high enough and the agent doesn\'t wait long enough to recieve enought messages to procceed with the protocol.\n\n\tinteger\n\n### Extra\nFor **Multi-Paxos** and **Multi-Raft** if nothing is defined in **agentDeaths**, the leader that has been first chosen will stay the leader for the whole simulation. To change that or specificly test the leader election, the following parameters where implemented:\n\n##### leaderDecidesOnlyOneValue\nif **true**, after the leader decides one value it changes its role to be a follower/acceptor again.\n\n\tbinary\n\n##### timoutChangeAfterLeaderDecided\nif **leaderDecidesOnlyOneValue = true**, the new leader will probably be the same agent again, because either the timeout is the fastest of all agents (Multi-Raft) or the agentID is the heighest (Multi-Paxos). To prevent that, after a leader decided one value his timeout can be delayed be the here specified value to make a leaderchange possible.\n\n\tnatural number\n\n## Visual parameters\nThe visualization of the Simulation can be altered, too. This has no effect on the procedures of the consensus protocols, but only on the visuals in the 3D Viewer. The following list will give an overview of all the visual parameters:\n\n##### message_distance\ndistance between message agents to the sending agent.\n\n\treal number\n\n### Height\nduring the simulation different heights can describe the phase of an agent. The different heights can be setup in the following variables:\n\n##### phase0Height\nheight for agents in phase 0.\n\treal number\n\n##### phase1Height\nheight for agents in phase 1.\n\n\treal number\n\n##### phase2Height\nheight for agents in phase 2.\n\n\treal number\n\n##### phase3Height\nheight for agents in phase 3.\n\n\treal number\n\n##### objectsMaxHeight\nthis sets the maximum height for timeout agents and the input/output block lists. The heightest point of these agents will always be maximum the defined value in **objectsMaxHeight**, and every other timeout and block will be relativly scaled.\n\n\treal number\n\n### Visibility\nThe following parameters will define, if some agents are visible or not.\n\n##### hideMessages\nif true: hides visually the message agents. (they still exist and work, but do not have any visualization)\n\n\tbinary\n\n##### hideTimouts\nif true: hides visually the timeout agents.\n\n\tbinary\n\n##### showInputblocks\nif true: shows the towers of input values behind the agents.\n\n\tbinary\n\n\n### Colors\nThe agents have different colors based on their role. All the role colors can be setup in the follower parameters:\n\n##### color0\n\n\tstandard: "blue"\n##### color1\n\n\tstandard: "yellow"\n##### color2\nif **valueIntervalSize = 3**, the color for the third value x=2 is exemplary defined in this value.\n\n\tstandard: "#123944"\n##### colorDead\n\n\tstandard: "black"\n##### colorUnkown\n\n\tstandard: "red"\n##### colorCandidateProposer\n\n\tstandard: "pink"\n##### colorLeader\n\n\tstandard: "purple"\n##### colorFollower\n\n\tstandard: "green"\n##### colorDivider\n\n\tstandard: "black"\n\n## Run the simulation\n\nClick the Play button or the Step Simulation button in the bottom right under the viewer.\nClick reset to reset the simulation to the initial state.',
        ref: "1.0",
      },
      {
        name: "globals.json",
        path: "src/globals.json",
        contents:
          '{\n  "algorithm": 0,\n  "numberOfAgents": 5,\n  "f": 0,\n  "valueListSize": 10,\n  "valueIntervalSize": 2,\n  "acceptanceThreshold": 0,\n  "agentDeaths": "",\n  "deathByStepOrRound": "step",\n  "randomDyingPercentage": 0,\n  "messageListRandomized": true,\n  "seed": "NestmannSchmid",\n  "randomScale": 9993,\n  "delayFunction": "gaus",\n  "messageMaxDelay": 10,\n  "g": 2,\n  "timeoutConstant": 10,\n  "leaderDecidesOnlyOneValue": false,\n  "timoutChangeAfterLeaderDecided": 10,\n  "message_distance": 1.7,\n  "phase0Height": 1,\n  "phase1Height": 2,\n  "phase2Height": 4,\n  "phase3Height": 7,\n  "objectsMaxHeight": 8,\n  "hideMessages": false,\n  "hideTimouts": false,\n  "showInputblocks": true,\n  "color0": "blue",\n  "color1": "yellow",\n  "color2": "#123944",\n  "colorDead": "black",\n  "colorUnkown": "red",\n  "colorCandidateProposer": "pink",\n  "colorLeader": "purple",\n  "colorFollower": "green",\n  "colorDivider": "black",\n  "schema": {"properties": {"agentDeaths": {"type": "string"}}}\n}',
        ref: "1.0",
      },
      {
        name: "analysis.json",
        path: "views/analysis.json",
        contents:
          '{\n  "outputs": {\n    "fRandomNumber": [{"op": "get", "field": "f"}, {"op": "mean"}],\n    "R_Messages": [\n      {"op": "filter", "field": "type", "comparison": "eq", "value": "R"},\n      {"op": "count"}\n    ],\n    "P_Messages": [\n      {"op": "filter", "field": "type", "comparison": "eq", "value": "P"},\n      {"op": "count"}\n    ],\n    "xIs0": [\n      {"op": "filter", "field": "x", "comparison": "eq", "value": 0},\n      {"op": "count"}\n    ],\n    "xIs1": [\n      {"op": "filter", "field": "x", "comparison": "eq", "value": 1},\n      {"op": "count"}\n    ],\n    "xIsUnknown": [\n      {"op": "filter", "field": "x", "comparison": "eq", "value": -1},\n      {"op": "count"}\n    ],\n    "Messages": [\n      {\n        "op": "filter",\n        "field": "agent_name",\n        "comparison": "gte",\n        "value": "msg"\n      },\n      {"op": "count"}\n    ],\n    "processesAlive": [\n      {\n        "op": "filter",\n        "field": "agent_name",\n        "comparison": "lte",\n        "value": "msg"\n      },\n      {"op": "filter", "field": "phase", "comparison": "neq", "value": "dead"},\n      {"op": "count"}\n    ],\n    "processesAll": [\n      {\n        "op": "filter",\n        "field": "agent_name",\n        "comparison": "lte",\n        "value": "msg"\n      },\n      {"op": "count"}\n    ],\n    "processesDead": [\n      {\n        "op": "filter",\n        "field": "agent_name",\n        "comparison": "lte",\n        "value": "msg"\n      },\n      {"op": "filter", "field": "phase", "comparison": "eq", "value": "dead"},\n      {"op": "count"}\n    ],\n    "Decision": [\n      {"op": "filter", "field": "agent_name", "comparison": "eq", "value": "0"},\n      {"op": "get", "field": "decided"},\n      {"op": "max"}\n    ]\n  },\n  "plots": [\n    {\n      "title": "MessageCount",\n      "type": "timeseries",\n      "data": [{"y": "Messages", "name": "Messages"}],\n      "layout": {\n        "height": "50%",\n        "width": "100%",\n        "hideLegend": false,\n        "hideCollatedLegend": false\n      },\n      "position": {"x": "0%", "y": "100%"}\n    },\n    {\n      "title": "Temporary Decisions (x)",\n      "type": "line",\n      "data": [\n        {"y": "xIs0", "name": "x = 0"},\n        {"y": "xIs1", "name": "x = 1"},\n        {"y": "xIsUnknown", "name": "x = ?"}\n      ],\n      "layout": {\n        "height": "50%",\n        "width": "100%",\n        "hideLegend": false,\n        "hideCollatedLegend": false\n      },\n      "position": {"x": "0%", "y": "50%"}\n    },\n    {\n      "title": "Counting Prozesses",\n      "type": "timeseries",\n      "data": [\n        {"y": "processesAll", "name": "All Processes"},\n        {"y": "processesDead", "name": "Dead Processes"},\n        {"y": "processesAlive", "name": "Alive Processes"}\n      ],\n      "layout": {\n        "height": "50%",\n        "width": "100%",\n        "hideLegend": false,\n        "hideCollatedLegend": false\n      },\n      "position": {"x": "0%", "y": "100%"}\n    }\n  ]\n}',
        ref: "1.0",
      },
      {
        name: "dependencies.json",
        path: "dependencies.json",
        contents: "{}",
        ref: "1.0",
      },
      {
        name: "experiments.json",
        path: "experiments.json",
        contents:
          '{\n  "SeedChange": {\n    "type": "values",\n    "values": [\n      "mtv",\n      "Nestmann",\n      "Schmid",\n      "Adler",\n      "Bisping",\n      "TU-Berlin"\n    ],\n    "steps": 2000,\n    "field": "seed"\n  },\n  "ValueListSize": {\n    "type": "values",\n    "values": [\n      1,\n      3,\n      5,\n      10\n    ],\n    "steps": 2000,\n    "field": "valueListSize"\n  },\n  "fSweep": {\n    "type": "values",\n    "values": [\n      0,\n      1,\n      2\n    ],\n    "steps": 2000,\n    "field": "f"\n  },\n  "delayFunction": {\n    "type": "values",\n    "values": [\n      "exp",\n      "lin",\n      "log",\n      "gaus"\n    ],\n    "steps": 20,\n    "field": "delayFunction"\n  },\n  "all_algorithms": {\n    "type": "values",\n    "values": [\n      0,\n      1,\n      2\n    ],\n    "steps": 3500,\n    "field": "algorithm"\n  }\n}',
        ref: "1.0",
      },
      {
        name: "init.js",
        path: "src/init.js",
        contents:
          '// Constant names\nconst PHASEDEAD = "dead";\nconst PROPOSER = "proposer";\nconst LEARNER = "learner";\nconst ACCEPTOR = "acceptor";\nconst PHASE1 = "promisePhase";\nconst PHASEACCEPTOR = "acceptorPhase";\nconst PREPARE = "prepareMSG";\nconst PROMISE = "promiseMSG";\nconst ACCEPT = "acceptMSG";\nconst ACCEPTED = "acceptedMSG";\nconst LeaderRequest = "leaderRequest";\nconst FollowerResponse = "followerResponse";\nconst LeaderPrepare = "LeaderPrepare";\nconst FollowerPrepare = "FollowerPrepare";\nconst LeaderAcknowledge = "LeaderAcknowledge";\nconst FollowerAcknowledge = "FollowerAcknowledge";\n\nvar globals;      // global access on globals without context\nvar random;       // global access for random function\nvar radius;       // global access for radius\nvar agentDeaths;  // global access for agentDeaths\n\n/**\n * Init the whole simulation. Needs to return an array of agents to run a simulation. (Hash specification)\n * Creates agentarray based on the parameters in globals.\n * Initializes global functions stdlib hack.\n * \n * @param {InitContext} context for initialization\n */\nconst init = (context) => {\n  globals = context.globals();\n\n  // init random function\n  let seed = cyrb128(globals["seed"]);\n  random = xoshiro128ss(seed[0], seed[1], seed[2], seed[3]);\n  // init vars and consts from globals\n  // Note: it is important, that this function is the first function using random being called after the initialization of random\n  let xValueLists = GetXValueLists();\n  radius = globals["numberOfAgents"];\n  const algorithm = globals["algorithm"];\n\n  InitAgentDeathObject();\n\n  // Create agentList by algorithm\n  let agents = []\n  switch (algorithm) {\n    case 0:\n      agents = StartMultiBenOr(xValueLists);\n      break;\n    case 1:\n      agents = StartMultiPaxos(xValueLists);\n      break;\n    case 2:\n      agents = StartMultiRaft(xValueLists);\n      break;\n    case 3:\n      agents = StartMessageDelayDistributionTest();\n      break;\n\n  }\n\n  initGlobalFunctions();\n\n  // build visualization of inputs\n  if (globals["showInputblocks"] && algorithm < 3) {\n    agents = agents.concat(GetInputvalueBlocks(xValueLists));\n  }\n\n\n  return agents;\n}\n\n\n// #region Start Algorithm Functions\n\n\n\n/**\n * Function to start Multi-Ben-Or Algorithm.\n */\nfunction StartMultiBenOr(xValueLists) {\n  let agents = [];\n\n  // Create Nodes\n  for (let i = 0; i < globals["numberOfAgents"]; i++) {\n    let xValueList = xValueLists[i];\n    let agent = GetMultiBenOrAgent(i, xValueList);\n    agent = DoomAgent(agent);\n\n    agents.push(agent);\n  }\n\n  // add gamemaster\n  agents.push(GetGameMaster())\n  return agents;\n}\n\n// MULTI PAXOS\nfunction StartMultiPaxos(xValueLists) {\n  const numberOfAgents = globals["numberOfAgents"];\n  let agents = [];\n\n  // Get Acceptors\n  for (let i = 0; i < numberOfAgents; i++) {\n    let xValueList = xValueLists[i];\n    let acceptorAgent = GetMultiPaxosAgent(i, ACCEPTOR, xValueList);\n    acceptorAgent = DoomAgent(acceptorAgent);\n    agents.push(acceptorAgent);\n  }\n\n  let timeoutNodes = getTimeoutNodes(agents);\n  agents = agents.concat(timeoutNodes);\n\n  // add gamemaster\n  agents.push(GetGameMaster())\n\n  return agents;\n}\n\n// MULTI RAFT\nfunction StartMultiRaft(xValueLists) {\n  const numberOfAgents = globals["numberOfAgents"];\n  let agents = [];\n  let timeoutList = GetTimeoutList();\n  // create agents\n  for (let i = 0; i < numberOfAgents; i++) {\n    let xValueList = xValueLists[i];\n    let raftNode = GetMultiRaftAgent(i, xValueList, timeoutList[i])\n    raftNode = DoomAgent(raftNode);\n    agents.push(raftNode);\n  }\n\n  let timeoutNodes = getTimeoutNodes(agents);\n  agents = agents.concat(timeoutNodes);\n\n  // add gamemaster\n  agents.push(GetGameMaster())\n\n  return agents;\n}\n\nfunction getTimeoutNodes(agents) {\n  let timeoutAgents = [];\n  if (!globals["hideTimouts"]) {\n    const maxTimeout = [].concat(agents).sort((a, b) => b.timeout - a.timeout)[0].timeout;\n    for (let i = 0; i < globals["numberOfAgents"]; i++) {\n      let timeoutAgent = GetTimeoutAgents(i, agents[i].wait, maxTimeout);\n      timeoutAgents.push(timeoutAgent);\n    }\n  }\n  return timeoutAgents;\n}\n\n/**\n * Returns a List of inputLists, with the index of each list in correlation to the agentnames.\n * \n * Note: it is important, that this function is the first one being called after the initialization\n * of the seed based pseudorandomnumber generator, because this way it can be ensured, that\n * all the different algorithms with the same numberOfAgents and seed will have the same inputs\n * for the same agents.\n */\nfunction GetXValueLists() {\n  const numberOfAgents = globals["numberOfAgents"];\n  var xValueLists = [];\n  for (let i = 0; i < numberOfAgents; i++) {\n    let xValueList = [];\n    for (let j = 0; j < globals["valueListSize"]; j++) {\n      xValueList.push(random(globals["valueIntervalSize"]));\n    }\n    xValueLists.push(xValueList);\n  }\n  return xValueLists;\n}\n\n\nfunction GetGameMaster() {\n  // Create Gamemaster\n  let gamemaster = {\n    "agent_name": "gamemaster",\n    "behaviors": ["gamemaster.js"],\n    "color": "black",\n    "shape": "cone",\n    "position": [radius + 6, 0, 1.5],\n    "direction": [0, 0, 1],\n    "resultLists": [],\n    "scale": [3, 3, 3],\n    "allMessages": []\n  }\n  return gamemaster;\n}\n\n/**\n * Starts test for distribution of messageDelay. Depends on\n * messageMaxDelay & delayFunction. Shows all possible values\n * for messageDelays as a plot of the heights of agents. If clicked\n * on one agent, the real delay can be seen under "delay".\n * \n * The height and width of the agents is \n */\nfunction StartMessageDelayDistributionTest() {\n  var agents = [];\n  const maxDelay = globals["messageMaxDelay"];\n  const maxHeightWeight = 15;\n  const heightScale = maxHeightWeight / maxDelay;\n  for (var i = 0; i < maxDelay + 1; i++) {\n    var agent = {\n      // STANDARD\n      "agent_name": i,\n      "behaviors": ["messageDelayDistributionTest.js"],\n      "position": [i * heightScale - (maxHeightWeight / 2), 0, 0],\n      "scale": [1, heightScale, 1],\n    }\n    agent.delay = getMessageDelay(i);\n    agent.height = agent.delay * heightScale;\n    agents.push(agent);\n  }\n\n  return agents;\n}\n\n/**\n * Due to Hash\'s lack of flexibility in setting up the globals,\n * there was the need to define a format that can be changed freely.\n * Therefore a string is being used and needs to be\n * interpreted in this function.\n * \n */\nfunction InitAgentDeathObject() {\n  var agentDeathString = globals["agentDeaths"];\n  agentDeaths = [];\n\n  // If death is defined\n  if (agentDeathString.length > 0) {\n    let agentDeathSplit = agentDeathString.split(\';\');\n    agentDeathSplit.forEach(agentDeath => {\n      agentDeathS = agentDeath.split(\',\');\n      agentDeaths[agentDeathS[0]] = agentDeathS[1];\n    });\n  }\n}\n\n/**\n * If an agentDeath is defined in agentDeaths, the death-date of the agent\n * is being set in this function.\n * \n * @param{agent} agent \n */\nfunction DoomAgent(agent) {\n  // If death is defined\n  if (agentDeaths != null) {\n    // Adding death\n    let doomsday = agentDeaths[agent.agent_name];\n    if (doomsday != null) {\n      agent.deathRound = doomsday;\n    }\n  }\n  return agent;\n}\n// #endregion\n\n// #region Node Constructor Functions\n\nfunction GetMultiBenOrAgent(agentID, xValueList) {\n  let agent = {\n    // STANDARD\n    "agent_name": agentID,\n    "behaviors": ["Multi_Ben_Or_Node.js"],\n    "position": positionInCircle(radius, agentID),\n    "scale": [1.6, 1.6, 1],\n    "color": getColor(xValueList[0]),\n    "height": globals["phase0Height"],\n    // USER\n    "phase": "p0",\n    "round": 0,\n    "globalRound": 0, // Round to work on values\n    "xValueList": xValueList, // List instead of one value\n    "x": xValueList[0],\n    "decided": null,\n    "decidedList": [],\n    "Rmsg": [],\n    "Pmsg": [],\n    "allMessages": [],\n  }\n  return agent;\n}\n\n\nfunction GetMultiPaxosAgent(agentID, role, xValueList) {\n  let agent = {\n    // STANDARD\n    "agent_name": agentID,\n    "behaviors": ["Multi_Paxos_Node.js"],\n    "position": positionInCircle(radius, agentID),\n    "scale": [1.6, 1.6, 1],\n    //"color": getColor(x, context),\n    "height": globals["phase0Height"],\n  }\n\n  // Round/Phase settings\n  agent.role = role;\n  agent.phase = role == PROPOSER ? PHASE1 : PHASEACCEPTOR; // Starting Phase\n  agent.color = globals["colorProposer"];\n  agent.round = 0; // Starting round\n  agent.globalRound = 0; // Round to work on values\n  agent.leader = null; // No Leader selected yet\n  // Values/Decision\n  agent.xValueList = xValueList; // List instead of one value\n  agent.x = xValueList[0]; // value to choose (first in List)\n  agent.decided = null; // No value decided yet\n  agent.decidedList = [];\n\n  // All message arrays prepared to access and save\n  agent.allMessages = [];\n  agent.promisedMsgs = [];\n  agent.acceptedMsgs = [];\n\n  // Settings from globals\n  agent.timeout = globals["messageMaxDelay"] * 2 + globals["timeoutConstant"];\n  agent.wait = role == PROPOSER ? 1 : agent.timeout;\n\n  return agent;\n}\n\nfunction GetMultiRaftAgent(agentID, xValueList, timeout) {\n  let agent = {\n    // STANDARD\n    "agent_name": agentID,\n    "behaviors": ["Multi_Raft_Node.js"],\n    "position": positionInCircle(radius, agentID),\n    "scale": [1.6, 1.6, 1],\n    //"color": getColor(x, context),\n    "height": globals["phase0Height"],\n    // USER\n    "xValueList": xValueList, // List instead of one value\n    "x": xValueList[0],\n    "decided": null,\n    "decidedList": [],\n    "allMessages": [],\n    "leader": null,\n    "color": globals["colorNoLeader"],\n    "voteMessages": [],\n  }\n  agent.role = "follower";\n  agent.term = 0;\n  agent.decided = null;\n  agent.allMessages = [];\n  agent.leader = null;\n  agent.globalRound = 0; // Round to work on values\n  agent.voteMessages = [];\n  agent.preparedMsgs = [];\n  agent.acknowledgedMsgs = [];\n  agent.timeout = timeout;\n  agent.wait = agent.timeout;\n\n  return agent;\n}\n\nfunction GetTimeoutList() {\n  const numberOfAgents = globals["numberOfAgents"];\n  var timeoutList = [];\n  for (let i = 0; i < numberOfAgents; i++) {\n    let randomValue = globals["messageMaxDelay"] * (i + 1) * 2 + globals["timeoutConstant"];\n    //(messageMaxDelay * (i+1)) * 2 + timeoutConstant$\n    timeoutList.push(Math.ceil(randomValue));\n  }\n  return shuffleArray(timeoutList);\n}\n\n/**\n * Creates\n * \n * @param{number} agentID ID or name of agent\n * @param{number} agentTimeout Timout of agent\n */\nfunction GetTimeoutAgents(agentID, agentTimeout, maxTimeout) {\n  let d2Position = positionInCircle(radius + 1, agentID);\n  let d3Position = [d2Position[0], d2Position[1], 0];\n  let agent = {\n    // STANDARD\n    "agent_name": agentID + "_timeout",\n    "behaviors": ["Timeout_Node.js"],\n    "position": d3Position,\n    "scale": [0.5, 0.5],\n    "color": "white",\n    "height": agentTimeout * globals["objectsMaxHeight"] / maxTimeout,\n    "timeout": agentTimeout,\n    "maxTimeout": maxTimeout,\n    // USER\n  }\n  agent.wait = agent.timeout;\n\n  return agent;\n}\n\n\nfunction GetInputvalueBlocks(xValueLists) {\n  blockAgents = [];\n  for (let i = 0; i < globals["numberOfAgents"]; i++) {\n    var blockList = buildBinaryBlocks(xValueLists[i], positionInCircle(radius + 3, i));\n    blockAgents = blockAgents.concat(blockList);\n  }\n  return blockAgents;\n}\n\n// #endregion\n\n// region Helper functions\n\n// region Random function\n/**\n * Returns a random function based on seed from globals.\n * Created in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)\n */\nfunction xoshiro128ss() {\n  let seed = cyrb128(globals["seed"]);\n  a = seed[0];\n  b = seed[1];\n  c = seed[2];\n  d = seed[3];\n\n  // Random Function\n  return function (num) {\n    var t = b << 9, r = a * 5; r = (r << 7 | r >>> 25) * 9;\n    c ^= a; d ^= b;\n    b ^= c; a ^= d; c ^= t;\n    d = d << 11 | d >>> 21;\n    let randomNumber = (r >>> 0) / 4294967296;\n    let randomInt = Math.floor(randomNumber * globals["randomScale"])\n    return randomInt % num;\n  }\n}\n\n/**\n * Hash function - Generates 4 hashes from seed to generate a random function.\n * Written in 01.12.2017 by bryc\n * https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n * https://github.com/bryc/code\n * \n * @param{string} str seed\n */\nfunction cyrb128(str) {\n  let h1 = 1779033703;\n  let h2 = 3144134277;\n  let h3 = 1013904242;\n  let h4 = 2773480762;\n  for (let i = 0, k; i < str.length; i++) {\n    k = str.charCodeAt(i);\n    h1 = h2 ^ Math.imul(h1 ^ k, 597399067);\n    h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);\n    h3 = h4 ^ Math.imul(h3 ^ k, 951274213);\n    h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);\n  }\n  h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);\n  h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);\n  h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);\n  h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);\n\n  a = (h1 ^ h2 ^ h3 ^ h4) >>> 0;\n  b = (h2 ^ h1) >>> 0;\n  c = (h3 ^ h1) >>> 0;\n  d = (h4 ^ h1) >>> 0;\n  return [a, b, c, d];\n}\n// endregion\n\n// region global functions\n\n/**\n * Initializes all global functions in stdlib.\n * (This is a small hack, to be able to use the same functions cross different files)\n */\nfunction initGlobalFunctions() {\n  globalThis.stdlib = {\n    random,\n    getMessageAgent,\n    getMessageDelay,\n    shuffleArray,\n    positionInCircle,\n    addPositions,\n    getColor,\n    updateTimeout,\n    allMessagesUpdate,\n    buildBinaryBlocks,\n    killAgentOnCondition\n  };\n}\n\n/**\n * Creates and gets an message agent.\n * \n * @param{AgentState} state agentstate\n * @param{message} message to be sent\n * @param{string} reciever to send the message to\n */\nfunction getMessageAgent(state, message, reciever) {\n  let messageAgent = {\n    // Hash parameters\n    "agent_name": "msg_" + state.agent_name + "To" + reciever,\n    "behaviors": ["msg.js"],\n    "position": stdlib.addPositions(state.position, stdlib.positionInCircle(globals["message_distance"], reciever)),\n    "scale": [0.5, 0.5],\n    // User parameters\n    "m": message,\n    "round": state.round,\n    "globalRound": state.globalRound,\n    "positionTo": stdlib.positionInCircle(radius, reciever),\n    "reciever": reciever,\n    "wait": stdlib.getMessageDelay(),\n    "type": message.type\n  }\n\n  const algorithm = globals["algorithm"];\n  switch (algorithm) {\n    case 0:\n      messageAgent = getMultiBenOrMessageAgent(messageAgent);\n      break;\n    case 1:\n      messageAgent = getMultiPaxosMessageAgent(state, messageAgent);\n      break;\n    case 2:\n      messageAgent = getMultiRaftMessageAgent(state, messageAgent);\n      break;\n  }\n\n  var height = messageAgent.height * 0.8;\n  messageAgent.direction = [0, 0, 1];\n  messageAgent.shape = "cylinder";\n  messageAgent.scale = [0.5, height, 0.5];\n  messageAgent.position = [messageAgent.position[0], messageAgent.position[1], height / 2];\n  messageAgent.positionTo = [messageAgent.positionTo[0], messageAgent.positionTo[1], messageAgent.position[2]];\n  messageAgent.height = 0.5;\n\n  return messageAgent;\n}\n\nfunction getMultiBenOrMessageAgent(messageAgent) {\n  messageAgent.color = getColor(messageAgent.m.data.value);\n  messageAgent.height = messageAgent.m.data.type == "R" ? globals["phase1Height"] : globals["phase2Height"];\n  messageAgent.value = messageAgent.m.data.value.value;\n  messageAgent.type = messageAgent.m.type;\n  messageAgent.Mathias = "hallo";\n  return messageAgent;\n}\n\n/**\n * Set\'s the color, shape, position adjustment\n * \n * @param {AgentState} state of the sending agent\n * @param {any} messageAgent messageAgent\n */\nfunction getMultiPaxosMessageAgent(state, messageAgent) {\n  messageAgent.color = state.color;\n  let value = messageAgent.m.data.value;\n\n  if (messageAgent.type == PREPARE) {\n    messageAgent.height = globals["phase1Height"];\n  } else if (messageAgent.type == PROMISE) {\n    messageAgent.height = globals["phase1Height"];\n    messageAgent.color = value ? "green" : "red";\n  } else if (messageAgent.type == ACCEPT) {\n    messageAgent.height = globals["phase2Height"];\n    messageAgent.color = getColor(messageAgent.m.data.value);\n  } else if (messageAgent.type == ACCEPTED) {\n    messageAgent.height = globals["phase2Height"];\n    messageAgent.color = value ? "green" : "red";\n  }\n\n  return messageAgent;\n}\n\n\nfunction getMultiRaftMessageAgent(state, messageAgent) {\n  let value = messageAgent.m.data.value ?? true;\n\n  // Follower message\n  if (messageAgent.type == FollowerResponse || messageAgent.type == FollowerPrepare || messageAgent.type == FollowerAcknowledge) {\n    messageAgent.color = value ? "green" : "red";\n    if (messageAgent.type == FollowerResponse) {\n      messageAgent.height = globals["phase0Height"];\n    } else if (messageAgent.type == FollowerPrepare) {\n      messageAgent.height = globals["phase1Height"];\n    } else if (messageAgent.type == FollowerAcknowledge) {\n      messageAgent.height = globals["phase2Height"];\n    }\n  }\n  // Leader message\n  else {\n    messageAgent.height = state.height;\n    if (messageAgent.type == LeaderRequest || messageAgent.type == LeaderPrepare) {\n      messageAgent.color = state.color;\n    }\n    else if (messageAgent.type == LeaderAcknowledge) {\n      messageAgent.color = getColor(messageAgent.m.data.value);\n    }\n  }\n  // messageAgent.shape = "sphere";\n  // messageAgent.height = 1;\n  return messageAgent;\n}\n\n/**\n * Returns message delay.\n * \n * Use of: random, messageMaxDelay, maxdelayFunction, \n * \n * random: function that returns int in range [0 - parameter-1]\n * \n * messageMaxDelay: maximum delay the message is delayed\n * \n * maxdelayFunction: distribution of randomness\n * \n * @param{specificValue} specificValue for distribution. Parameter can be passed for\n * a specific value (as in delayDistributionTest) as randomValue. If empty (normally), it get#s\n * randomly set between 0 and messageMaxDelay\n */\nfunction getMessageDelay(specificValue) {\n  maxDelay = globals["messageMaxDelay"];\n  randomValue = specificValue ?? random(maxDelay);\n\n  let returnValue = 0;\n  const functionType = globals["delayFunction"];\n  switch (functionType) {\n    // linear\n    case "lin":\n      returnValue = randomValue;\n      break;\n    // logarithmic (natural)\n    case "log":\n      var logScaleFactor = (maxDelay / Math.log(1 + maxDelay));\n      var log = Math.log(1 + randomValue) * logScaleFactor;\n      returnValue = Math.ceil(log);\n      break;\n    // exponential\n    case "exp":\n      var expScaleFactor = Math.exp(maxDelay);\n      let exp = (Math.exp(randomValue) / expScaleFactor) * maxDelay;\n      returnValue = Math.floor(exp);\n      break;\n    case "gaus":\n      // gaussian function\n      // the idea here is, to have a gauss bell function, that is scaled, so that input and output roughly range from 0 -> 100\n      const gausParam = globals["g"];\n      let randomValueShifted = randomValue / maxDelay - (1 / 2);\n      let randomValueShiftedScaled = randomValueShifted * gausParam;\n      let gausBellCurve = Math.exp(-(randomValueShiftedScaled * randomValueShiftedScaled));\n      returnValue = Math.floor((maxDelay * gausBellCurve));\n  }\n\n  return returnValue;\n}\n\n/**\n * Simple shuffle for an array,\n * used to change the order of messages recieved for each agent.\n * \n * @param{array} array array to be shuffled\n */\nfunction shuffleArray(array) {\n  if (globals["messageListRandomized"]) {\n    for (var i = array.length - 1; i > 0; i--) {\n      // Generate random number\n      var j = random(array.length);\n      var temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n    }\n  }\n  return array;\n}\n\n/**\n * Returns a position based on a circle, divided in equal parts through the number of agents.\n * \n * @param{number} parameterRadius radius from [0,0]\n * @param{number} member_id ID for position in circle\n */\nfunction positionInCircle(parameterRadius, member_id) {\n  const numberOfAgents = globals["numberOfAgents"];\n  const localRadius = parameterRadius;\n  // divide circle equaly through number of agents\n  const factor = ((2 * Math.PI) / numberOfAgents);\n  // math comes from complex numbers\n  let angle = factor * member_id;\n  let real = localRadius * Math.cos(angle);\n  let im = localRadius * Math.sin(angle);\n  // 2D position\n  let position = [real, im];\n  return position;\n}\n\n/**\n * Adds to positions together to one\n * \n * @param{array} position1 \n * @param{array} position2 \n */\nfunction addPositions(position1, position2) {\n  let x = position1[0] + position2[0];\n  let y = position1[1] + position2[1];\n  let position = [x, y];\n  return position;\n}\n\n/**\n * Returns color based on given value.\n * -1 = red, 0 = color0 (globals), 1 = color1 (globals), else is green\n * \n * @param {number} value (mostly) decision value of agent \n */\nfunction getColor(value) {\n  switch (value) {\n    case -1:\n      return globals["colorUnkown"];\n    case 0:\n      return globals["color0"];\n    case 1:\n      return globals["color1"];\n    case 2:\n      return globals["color2"];\n    default:\n      return globals["colorUnkown"];\n  }\n}\n\n/**\n * Updates timeout agents to animate in view. Only works, if "hideTimouts": false.\n * \n * (Only visuals, no functionality)\n * \n * @param{AgentState} state state for agentname and wait information.\n */\nfunction updateTimeout(state) {\n  let msg = {\n    to: state.agent_name + "_timeout",\n    type: "height",\n    data: {\n      value: state.wait,\n    },\n  };\n  state.messages.push(msg);\n}\n\n/**\n * Updates all messages from an agents,\n * but filtered by globalRound for effiency.\n * \n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agen\n */\nfunction allMessagesUpdate(state, context) {\n  let oldAndNewMessages = state.allMessages.concat(context.messages());\n  let filteredRelevantMessages = oldAndNewMessages.filter(m => m.data.globalRound >= state.globalRound - 1);\n  state.allMessages = filteredRelevantMessages;\n}\n\n/**\n * Builds tower of binary values\n * \n * @param{binaryList} binaryList\n * @param{position} position\n */\nfunction buildBinaryBlocks(binaryList, position) {\n  var index = 0;\n  var blockList = [];\n  var blockHeight = globals["objectsMaxHeight"] / binaryList.length;\n  var dividerHeight = blockHeight * 1 / 5;\n  binaryList.forEach(res => {\n\n    var block = {\n      "agent_name": "result_" + index,\n      "position": [position[0], position[1], index * blockHeight + dividerHeight],\n      "height": blockHeight - dividerHeight,\n      "color": stdlib.getColor(res),\n    };\n    var divider = {\n      "agent_name": "spacer_" + index,\n      "position": [position[0], position[1], index * blockHeight],\n      "height": dividerHeight,\n      "color": globals["colorDivider"],\n    };\n\n    blockList = blockList.concat([divider, block]);\n    index++;\n  });\n  return blockList;\n}\n\n/**\n * If one of the conditions is met, agent goes into his death phase.\n * \n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nfunction killAgentOnCondition(state, context) {\n  // condition 1 is kill for round\n  let cond1 = globals["deathByStepOrRound"] == "round" && state.deathRound != null && state.deathRound <= state.globalRound;\n  // condition 2 is kill for step\n  let cond2 = globals["deathByStepOrRound"] == "step" && state.deathRound != null && state.deathRound <= context.step();\n\n  if (cond1 || cond2) {\n    state.phase = PHASEDEAD;\n    state.color = globals["colorDead"];\n  }\n  // RANDOM DYING\n  else if (state.phase != PHASEDEAD && globals["randomDyingPercentage"] > 0) {\n    let randomDieScale = Math.ceil((100 / globals["randomDyingPercentage"]));\n    let randomNumber = random(randomDieScale);\n    state.randomDieScale = randomDieScale;\n    state.randomDieValue = randomNumber;\n    if (0 == randomNumber) {\n      state.deathCause = globals["randomDyingPercentage"] + " > " + randomNumber;\n      state.phase = PHASEDEAD;\n      state.color = globals["colorDead"];\n    }\n  }\n}\n// endregion\n// endregion',
        ref: "1.0",
      },
      {
        name: "gamemaster.js",
        path: "src/behaviors/gamemaster.js",
        contents:
          'const ENDPHASE = "endPhase";\n\n/**\n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nconst behavior = (state, context) => {\n  const n = context.globals()["numberOfAgents"];\n  state.allMessages = state.allMessages.concat(context.messages());\n  let maxDeadAgents = Math.floor((Object.keys(context.globals()["agentDeaths"] ?? 0).length+1) / 4);\n  let acceptanceThreshold = Math.max(context.globals()["acceptanceThreshold"], maxDeadAgents);\n  let resultList = state.resultLists.find(s => s);\n\n  state.acceptanceThreshold = acceptanceThreshold;\n\n  if (state.phase != ENDPHASE) {\n\n    context.messages().forEach(m => {\n      state.resultLists[m.data.frm] = m.data.decidedList;\n    });\n\n\n    // if all messages arrived\n    let falseMessages = 0;\n    for (i = 0; i < n; i++) {\n      if (state.resultLists[i] == null) {\n        falseMessages++;\n      }\n    }\n\n    // if enough decidedLists recieved\n    if (falseMessages <= acceptanceThreshold && resultList != null) {\n      // "print" resultList\n      var blockList = stdlib.buildBinaryBlocks(resultList, [0, 0]);\n      blockList.forEach(block => {\n        state.addMessage("hash", "create_agent", block);\n      });\n      state.blockList = blockList;\n      state.phase = ENDPHASE;\n    }\n  } else {\n    state.color = "white";\n\n    let algorithmName = "no algorithmName";\n    switch (context.globals()["algorithm"]) {\n      case 0:\n        algorithmName = "Multi-Ben-Or";\n        break;\n      case 1:\n        algorithmName = "Multi-Paxos";\n        break;\n      case 2:\n        algorithmName = "Multi-Raft";\n        break;\n    }\n\n    let rsn = algorithmName + " consensus: [" + resultList\n      + "], \\n acceptanceThreshold: " + (acceptanceThreshold);\n    state.addMessage("hash", "stop", {\n      status: "success", reason: rsn\n    });\n  }\n\n\n};\n',
        ref: "1.0",
      },
      {
        name: "gamemaster.js.json",
        path: "src/behaviors/gamemaster.js.json",
        contents:
          '{\n\t"keys": {\n\t\t"results": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"wait": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"allMessages": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"phase": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t}\n\t},\n\t"built_in_key_use": null,\n\t"dynamic_access": false\n}',
        ref: "1.0",
      },
      {
        name: "messageDelayDistributionTest.js",
        path: "src/behaviors/messageDelayDistributionTest.js",
        contents:
          '/**\n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nconst behavior = (state, context) => {\n  state.addMessage("hash", "stop", {\n      status: "success", reason: "TEST ok"\n    });\n};\n',
        ref: "1.0",
      },
      {
        name: "messageDelayDistributionTest.js.json",
        path: "src/behaviors/messageDelayDistributionTest.js.json",
        contents:
          '{\n\t"keys": {},\n\t"built_in_key_use": null,\n\t"dynamic_access": false\n}',
        ref: "1.0",
      },
      {
        name: "msg.js",
        path: "src/behaviors/msg.js",
        contents:
          '/**\n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nconst behavior = (state, context) => {\n  // waiting the simulated delay\n  if (state.wait > 0) {\n    state.wait--;\n  } else {\n    if (!state.end) {\n      // send the message\n      state.messages.push(state.m);\n      state.end = true;\n    } else {\n      if (!state.kill) {\n        // goes to the position of reciever\n        state.position = state.positionTo;\n        state.kill = true;\n      } else {\n        // message agent kills himself\n        state.addMessage("hash", "remove_agent");\n      }\n    }\n  }\n  // HACK: If uncommented, the message agents disapper from visual representation\n  if (context.globals()["hideMessages"]) {\n    state.position = null;\n  }\n};\n',
        ref: "1.0",
      },
      {
        name: "msg.js.json",
        path: "src/behaviors/msg.js.json",
        contents:
          '{\n\t"keys": {\n\t\t"wait": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"reciever": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"type": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"value": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"round": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"end": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"kill": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"positionTo": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"nachricht": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"m": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t}\n\t},\n\t"built_in_key_use": null,\n\t"dynamic_access": false\n}',
        ref: "1.0",
      },
      {
        name: "Multi_Ben_Or_Node.js",
        path: "src/behaviors/Multi_Ben_Or_Node.js",
        contents:
          'const PHASE0 = "p0";\nconst PHASE1 = "p1";\nconst PHASE2 = "p2";\nconst PHASEDECIDED = "decidePhase";\nconst PHASEFINISH = "FinishPhase";\nconst PHASEDEAD = "dead";\nconst R = "R";\nconst P = "P";\n\n/**\n * Multi-Ben-Or algorithm\n * \n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nconst behavior = (state, context) => {\n  // update inbox\n  stdlib.allMessagesUpdate(state, context);\n  // kill agent if round or step condition is true\n  stdlib.killAgentOnCondition(state, context);\n\n\n  // main algorithm\n  const numberOfAgents = context.globals()["numberOfAgents"];\n  var f = context.globals()["f"];\n  const maxF = Math.floor((numberOfAgents-1) / 2);\n  if (f < 0 || f > maxF) {\n    f = maxF;\n  }\n  state.f = f;\n\n  // Phase 0\n  if (state.phase == PHASE0) {\n    // init round, update view\n    state.height = context.globals()["phase0Height"];\n    state.round = state.round + 1;\n    state.color = stdlib.getColor(state.x);\n    Send(state, context, R, state.x);\n\n    // init first phase\n    state.phase = PHASE1;\n  }\n  // Phase 1\n  else if (state.phase == PHASE1) {\n    // wait for messages of the form (R, r, globalRound, *) from k  f processes\n    state.Rmsg = waitMessages(state, R);\n    if (state.Rmsg.length >= (numberOfAgents - f)) {\n      for (i = 0; i < context.globals()["valueIntervalSize"]; i++) {\n        // if recieved more than k/2 (R, k, v) with the same v then\n        let rMsgs = state.Rmsg.filter(msg => msg.data.value == i);\n        if (rMsgs.length > (numberOfAgents / 2)) {\n          state.x = i;\n          Send(state, context, P, i);\n          // init next phase\n          state.phase = PHASE2;\n        }\n      }\n\n      // else send (R, r, globalRound, ?) to all processes\n      if (state.phase == PHASE1) {\n        state.x = -1;\n        Send(state, context, P, -1)\n        // init next phase\n        state.phase = PHASE2;\n      }\n\n\n    }\n    // update view\n    state.height = context.globals()["phase1Height"];\n    state.color = stdlib.getColor(state.x);\n  }\n  // Phase 2\n  else if (state.phase == PHASE2) {\n    // update view\n    state.height = context.globals()["phase2Height"];\n    state.color = stdlib.getColor(state.decided ?? state.x);\n\n    // wait for messages of the form (P, r, globalRound, ) from k  f processes\n    state.Pmsg = waitMessages(state, P);\n    if (state.Pmsg.length >= (numberOfAgents - f)) {\n      // if recieved at least f + 1 (P, r, globalRound, v) with the same v = ? \n      for (i = 0; i < context.globals()["valueIntervalSize"]; i++) {\n        let pMsgs = state.Pmsg.filter(msg => msg.data.value == i);\n        if (pMsgs.length >= (f + 1)) {\n          // decide\n          state.decided = i;\n          // init end phase\n          state.phase = PHASEDECIDED;\n          break;\n        }\n      }\n      // else if at least one (P, r, globalRound, ) with v = ?\n      if (state.phase == PHASE2) {\n        for (i = 0; i < context.globals()["valueIntervalSize"]; i++) {\n          let pMsgs = state.Pmsg.filter(msg => msg.data.value == i);\n          if (pMsgs.length > 0) {\n            state.x = i;\n            // init next round\n            state.phase = PHASE0;\n            state.phase0Reason = "Least " + (pMsgs.length) + ", Type: " + i;\n            break;\n          }\n        }\n      }\n      // else random\n      if (state.phase == PHASE2) {\n        state.x = stdlib.random(context.globals()["valueIntervalSize"]);\n        // init next round\n        state.phase = PHASE0;\n        state.phase0Reason = "Random, Type: " + state.x;\n      }\n    }\n  }\n\n  // PHASEDECIDED\n  if (state.phase == PHASEDECIDED && state.decided != null) {\n    // update view\n    state.height = context.globals()["phase3Height"];\n    state.color = stdlib.getColor(state.decided);\n\n    // decide\n    state.decidedList = state.decidedList.concat(state.decided)\n\n    // if not all decisions made\n    if (state.decidedList.length < state.xValueList.length) {\n      // init next global round\n      let nextGlobalRound = state.globalRound + 1;\n      state.globalRound = nextGlobalRound;\n      state.x = state.xValueList[nextGlobalRound];\n      state.decided = null;\n      state.phase = PHASE0;\n      state.round = 0;\n      // Hack: if performance is very bad, "state.allMessages = [];" can be added, but the algorithm is less stable\n    }\n    // else if finished all decisions\n    else {\n      // return decidedListp\n      state.addMessage("gamemaster", "decided", {\n        "frm": state.agent_name,\n        "decidedList": state.decidedList\n      });\n      // wait for others to finish deciding\n      state.phase = PHASEFINISH;\n    }\n  }\n};\n\n/**\n * Sends to every agent a message\n * \n * @param {AgentState} state state of the agent\n * @param {AgentContext} context context of the agent\n * @param {string} type kind of message\n * @param {string} value value in the message\n */\nfunction Send(state, context, type, value) {\n  const n = context.globals()["numberOfAgents"];\n  for (let reciever = 0; reciever < n; reciever++) {\n    //  actual message that the agents should recieve\n    let msg = {\n      to: reciever,\n      type: type,\n      data: {\n        value: value,\n        round: state.round,\n        globalRound: state.globalRound,\n        type: type,\n        frm: state.agent_name\n      },\n    };\n\n    // Create message agent with necessary parameters and msg in m\n    let messageAgent = stdlib.getMessageAgent(state, msg, reciever);\n\n    state.addMessage("hash", "create_agent", messageAgent);\n  }\n};\n\n/**\n * Filters all messages for globalRound, round and given message type and returns the filtered message list.\n * \n * @param {AgentState} state of the agent\n * @param {string} type message type (R or P)\n */\nfunction waitMessages(state, type) {\n  // Filter all the messages for the desired conditions\n  let allMessagesForThisGlobalRound = state.allMessages.filter((msg) => msg.data.globalRound == state.globalRound);\n  let allMessagesForThisRound = allMessagesForThisGlobalRound.filter((msg) => msg.data.round == state.round);\n  let messagesWithType = allMessagesForThisRound.filter((msg) => msg.type == type);\n  let messagesWithoutOwn = messagesWithType.filter((msg) => msg.data.frm != state.agent_name);\n  return stdlib.shuffleArray(messagesWithType);\n}',
        ref: "1.0",
      },
      {
        name: "Multi_Ben_Or_Node.js.json",
        path: "src/behaviors/Multi_Ben_Or_Node.js.json",
        contents:
          '{\n\t"keys": {\n\t\t"allMessages": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"round": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"phase": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"x": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"Rmsg": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"Pmsg": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"decided": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"decidedList": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"valueRound": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"xValueList": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"wait": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"f": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"RmsgLength": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"nminusf": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"globalRound": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"deathRound": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"conditions": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"cond1": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"cond2": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"phase0Reason": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t}\n\t},\n\t"built_in_key_use": null,\n\t"dynamic_access": false\n}',
        ref: "1.0",
      },
      {
        name: "Multi_Paxos_Node.js",
        path: "src/behaviors/Multi_Paxos_Node.js",
        contents:
          '// Messages\nconst PREPARE = "prepareMSG";\nconst PROMISE = "promiseMSG";\nconst ACCEPT = "acceptMSG";\nconst ACCEPTED = "acceptedMSG";\n// Roles\nconst PROPOSER = "proposer";\nconst LEARNER = "learner";\nconst ACCEPTOR = "acceptor";\n// Phases\nconst PHASEACCEPTOR = "acceptorPhase";\nconst PHASE1 = "promisePhase";\nconst PHASE2 = "acceptPhase";\nconst PHASEDEAD = "dead";\nconst PHASEFINISH = "FinishPhase";\n\n/**\n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nconst behavior = (state, context) => {\n  stdlib.killAgentOnCondition(state, context);\n  stdlib.updateTimeout(state);\n\n  // numberOfAgents = k from Pseudocode\n  const numberOfAgents = context.globals()["numberOfAgents"];\n  const MINAGREEABLEAGENTS = (numberOfAgents / 2); // +1 comes from self\n  state.allCurrentMessages = context.messages();\n  stdlib.allMessagesUpdate(state, context);\n  if (state.phase != PHASEDEAD && state.phase != PHASEFINISH) {\n\n    // Choose Leader\n    // PROMISE - Acceptor Phase 1\n    let unsortedPrepareMsgs = state.allCurrentMessages.filter(m => m.type == PREPARE && m.data.globalRound == state.globalRound);\n    // (Always) listen for messages of the form (leaderRequest, proposedN, r, globalRound) from any processe\n    let prepareMsgs = sortMsgsByProposedN(unsortedPrepareMsgs);\n    state.height = context.globals()["phase1Height"];\n    if (prepareMsgs.length > 0) {\n      prepareMsgs.forEach(m => {\n        let msgData = m.data;\n        let proposedN = msgData.n;\n        // PROMISE Conditions\n        let noPromisedNYet = state.promisedN == null;\n        let promisedNIsSmallerThanProposedN = state.promisedN != null && parseInt(state.promisedN) < parseInt(proposedN);\n        // Approve PROMISE\n        // if recieved at least one message with promisedN < proposedN then\n        if (noPromisedNYet || promisedNIsSmallerThanProposedN) {\n          state.phase = PHASEACCEPTOR;\n          state.role = ACCEPTOR;\n          state.wait = state.timeout;\n          state.promisedN = parseInt(proposedN); // Integer save\n          state.leader = msgData.frm;\n          state.round = msgData.round;\n          state.globalRound = msgData.globalRound;\n          SendTo(state, PROMISE, true, msgData.frm, state.promisedN);\n        }\n        // Disapprove PROMISE (for faster progress in asynchronus system)\n        else {\n          SendTo(state, PROMISE, false, msgData.frm, state.promisedN);\n        }\n      });\n    }\n\n    //  Acceptor\n    if (state.role == ACCEPTOR) {\n      state.height = context.globals()["phase2Height"]; // indicate phase 2 (Waiting for Acceptmessage)\n      state.color = context.globals()["colorFollower"];\n      // Acceptor Phase 2 \n      if (state.wait > 0 && state.leader != null) {\n        // ACCEPT - Acceptor Phase 2\n        // wait for messages of the form (Accept, promisedN, v, r, globalRound) for the time of timeoutp\n        let acceptMsgs = state.allCurrentMessages.filter(m => m.type == ACCEPT && m.data.globalRound == state.globalRound);\n        if (acceptMsgs.length > 0) {\n          acceptMsgs.forEach(m => {\n            let msgData = m.data;\n            let sender = msgData.frm;\n            let proposedN = parseInt(msgData.n);\n            let msgRound = msgData.round;\n            let proposedValue = msgData.value;\n            // ACCEPT Conditions\n            let noPromisedNYet = state.promisedN == null;\n            let promisedNIsSmallerThanOrEqualProposedN = state.promisedN != null && parseInt(state.promisedN) <= parseInt(proposedN);\n            // Approve ACCEPT\n            if (noPromisedNYet || promisedNIsSmallerThanOrEqualProposedN) {\n              if (state.decided == null) {\n                state.wait = state.timeout;\n                // decidedp  v, decidedListp[globalRound]  decidedp\n                state.decided = proposedValue;\n                state.decidedList = state.decidedList.concat([state.decided]);\n                // send (Accepted, true, r, globalRound) back to proposer process\n                SendTo(state, ACCEPTED, true, msgData.frm);\n                // if all decisions made\n                if (state.xValueList.length == state.decidedList.length) {\n                  // return decidedListp\n                  state.addMessage("gamemaster", "decided", {\n                    "frm": state.agent_name,\n                    "decidedList": state.decidedList,\n                    "role": ACCEPTOR\n                  });\n                  state.phase = PHASEFINISH;\n                  state.height = context.globals()["phase3Height"];\n                } else {\n                  // reset agent for next round\n                  state.globalRound++; // Round to work on values\n                  state.phase = PHASEACCEPTOR; // Starting Phase\n                  state.round = 0; // Starting round\n                  state.decided = null; // No value decided yet\n                }\n              }\n            }\n            // Disapprove ACCEPT\n            else {\n              // TODO: NOT RIGHT\n              // SendTo(state, context, ACCEPTED, state.roundID, msgData.frm);\n            }\n          });\n        }\n      } else {\n        state.role = PROPOSER;\n        state.phase = PHASE1;\n        state.wait = 1;\n        state.leader = null;\n      }\n    }\n\n    //  Proposer\n    if (state.role == PROPOSER) {\n      state.color = context.globals()["colorCandidateProposer"];\n      // wait for messages of the form (promise, , r, globalRound) for the time of timeoutp\n      let newPromisedMsgs = state.allCurrentMessages.filter(m => m.type == PROMISE && m.data.globalRound == state.globalRound);\n      state.promisedMsgs = state.promisedMsgs.concat(newPromisedMsgs);\n      let promisedMsgs = state.promisedMsgs;\n      let truePromisedMsgs = promisedMsgs.filter(m => m.data.value == true);\n      if (state.phase == PHASE1) {\n        // if recieved more than k/2 messages with (promise, true, r, globalRound) then\n        if (state.decided == null && truePromisedMsgs.length + 1 > MINAGREEABLEAGENTS) {\n          state.phase = PHASE2;\n          state.wait = 0;\n        } else {\n          //  Proposer Phase 1\n          state.height = context.globals()["phase1Height"];  // indicate phase 1\n          // Send PREPARE message\n          if (state.wait < 1) {\n            // New round preperation\n            state.wait = state.timeout;\n            state.promisedMsgs = []; // clear promised Msgs\n            state.round++; // Add round\n\n            // proposedN  getU niqueN (k, r, globalRound, agentID)\n            state.proposedN = (numberOfAgents - 1) * state.globalRound + (numberOfAgents - 1) * state.round + state.agent_name; // unique request identifier\n            state.promisedN = state.proposedN;\n            // send (leaderRequest, proposedN, r, globalRound) to all processes\n            Send(state, context, PREPARE, \'Promised N message\');\n          }\n        }\n      }\n      //  Proposer Phase 2\n      if (state.phase == PHASE2) {\n        state.color = context.globals()["colorLeader"];\n        state.height = context.globals()["phase2Height"];; // indicate phase 2\n\n        if (state.wait < 1) {\n          // x  valueListp[globalRound]\n          state.x = state.xValueList[state.globalRound];\n          // send (Accept, promisedN, x, r, globalRound) to all processes\n          Send(state, context, ACCEPT, state.x);\n          // RESET\n          state.wait = state.timeout;\n        }\n\n        // wait for messages of the form (Accepted, , r, globalRound) for the time of timeoutp\n        let newAcceptedMsgs = state.allCurrentMessages.filter(m => m.type == ACCEPTED && m.data.globalRound == state.globalRound);\n        state.acceptedMsgs = state.acceptedMsgs.concat(newAcceptedMsgs);\n        let acceptedMsgs = state.acceptedMsgs;\n        let trueAcceptedMsgs = acceptedMsgs.filter(m => m.data.value == true);\n        //if recieved more than k/2 messages with (Accepted, true, r, globalRound) then\n        if (trueAcceptedMsgs.length + 1 > MINAGREEABLEAGENTS) {\n          // decided  x\n          state.decided = state.x;\n          // decidedListp[globalRound]  decidedp\n          state.decidedList = state.decidedList.concat([state.decided]);\n          state.wait = state.timeout;\n          // Start new global round (Reset values)\n          if (state.globalRound + 1 < state.xValueList.length) { // TODO: Check equation\n            // init next round\n            state.globalRound++;\n            state.phase = PHASE1; // Starting Phase\n            state.round = 0; // Starting round\n            // x  valueListp[globalRound]\n            state.x = state.xValueList[state.globalRound];\n            state.decided = null; // decided reset\n\n            // state.promisedN and state.promisedMsgs won\'t be reset. Therefore the promised message from\n            // last round are staying and only the acceptRequests are being sent\n            state.acceptedMsgs = [];\n            \n\n            // Visuals\n            state.wait = 1;\n\n            // If leader should change after one decision (forced 3PC instead of 2PC)\n            if (context.globals()["leaderDecidesOnlyOneValue"]) {\n              state.promisedMsgs = [];\n              if (context.globals()["timoutChangeAfterLeaderDecided"] != null) {\n                state.wait = state.timeout + context.globals()["timoutChangeAfterLeaderDecided"];\n              } else {\n                state.wait = state.timeout;\n              }\n            }\n\n          }\n          // End whole simulation\n          else {\n            // return decidedListp\n            state.addMessage("gamemaster", "decided", {\n              "frm": state.agent_name,\n              "decidedList": state.decidedList,\n              "role": PROPOSER\n            });\n            state.phase = PHASEFINISH;\n            state.height = context.globals()["phase3Height"];\n          }\n        }\n      }\n    }\n\n    // timeout update\n    state.wait--;\n  }\n}\n\n/**\n * @param {string} R kind of message\n * @param {AgentState} state of the agent\n */\nfunction Send(state, context, type, value) {\n  const numberOfAgents = context.globals()["numberOfAgents"];\n  for (let reciever = 0; reciever < numberOfAgents; reciever++) {\n    if (reciever != state.agent_name) {\n      SendTo(state, type, value, reciever);\n    }\n  }\n};\n\nfunction SendTo(state, type, value, reciever) {\n  let msg = getMessage(state, type, value, reciever);\n  let messageAgent = stdlib.getMessageAgent(state, msg, reciever);\n  state.addMessage("hash", "create_agent", messageAgent);\n\n}\n\nfunction getMessage(state, type, value, reciever) {\n  let msg = {\n    to: reciever,\n    type: type,\n    data: {\n      frm: state.agent_name,\n      value: value,\n      round: state.round,\n      globalRound: state.globalRound,\n      n: state.promisedN,\n      type: type\n    },\n  };\n  return msg;\n}\n\n/**\n * Sorts given array by their n.\n * \n * This is important, due to that hash has no real time measurement.\n * So in one step multiple messages can arrive, but when the agent behaves\n * on multiple messages in the same step and accepts the n of 2 agents at\n * the same "time", 2 proposers will think they are accepted. By sorting\n * the array we know there will be at most one n accepted per step.\n * \n * @param {array} msgArray \n * @returns {array}\n */\nfunction sortMsgsByProposedN(msgArray) {\n  let sortedMsgArray = msgArray.sort((a, b) => b.data.n - a.data.n);\n  return sortedMsgArray;\n}',
        ref: "1.0",
      },
      {
        name: "Multi_Paxos_Node.js.json",
        path: "src/behaviors/Multi_Paxos_Node.js.json",
        contents:
          '{\n\t"keys": {\n\t\t"allMessages": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"dieTimer": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"leader": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"phase": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"voteMessages": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"wait": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"timeout": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"roles": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"promisedMsgs": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"decided": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"round": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"promisedN": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"value": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"acceptedMsgs": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"decidedList": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"globalRound": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"xValueList": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"roundID": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t}\n\t},\n\t"built_in_key_use": null,\n\t"dynamic_access": false\n}',
        ref: "1.0",
      },
      {
        name: "Multi_Raft_Node.js",
        path: "src/behaviors/Multi_Raft_Node.js",
        contents:
          'const CANDIDATE = "candidate";\nconst FOLLOWER = "follower";\nconst LEADER = "leader";\nconst PHASEDEAD = "dead";\nconst PHASEFINISH = "FinishPhase";\nconst LeaderRequest = "leaderRequest";\nconst FollowerResponse = "followerResponse";\nconst LeaderPrepare = "LeaderPrepare";\nconst FollowerPrepare = "FollowerPrepare";\nconst LeaderAcknowledge = "LeaderAcknowledge";\nconst FollowerAcknowledge = "FollowerAcknowledge";\n\n/**\n * Multi-Raft algorithm\n * \n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nconst behavior = (state, context) => {\n  // kill agent if round or step condition is true\n  stdlib.killAgentOnCondition(state, context);\n\n  // RAFT algorithm\n  if (state.phase != PHASEDEAD && state.role != PHASEFINISH) {\n    // algorithm preparation\n    const n = context.globals()["numberOfAgents"];\n    let allCurrentMessages = context.messages();\n    // Timeout update\n    state.wait--;\n    stdlib.updateTimeout(state)\n\n    // FOLLOWER\n    // in this implementation, everyone is all the time a follower\n    // If desired differently, uncomment hack in line 62\n    //  Choose Leade\n    //  Follower Phase 1 - ELECTION PHASE (Follower chooses Leader)\n    // Everyone always listens to leader requests.\n    // If a new leader requests leadership, everyone needs to answer inspite of the phase the agent is currently in\n    let leaderRequests = allCurrentMessages.filter(m => m.type == LeaderRequest && m.data.globalRound >= state.globalRound);\n    if (leaderRequests.length > 0) {\n      let leaderMessage = stdlib.shuffleArray(leaderRequests)[0];\n      state.lastLeaderRequest = leaderMessage;\n      state.globalRound = leaderMessage.data.globalRound;\n      let newLeader = leaderMessage.data.value;\n      if (newLeader != state.agent_name) {\n        state.leader = newLeader;\n        state.role = FOLLOWER;\n        state.voteMessages = [];\n        state.wait = state.timeout;\n        state.prepared = false;\n        SendTo(state, context, FollowerResponse, true, newLeader);\n      }\n    }\n\n    // Acutal FOLLOWER ROLE\n    // if desired, the follower phase can be seperated. The code will produce the smae results.\n    // Maybe it increases efficiency, but this way it increases the possiblity to find consesus,\n    // because in a non-byzantine environment it\'s possible to assume, that only messages will\n    // be sent from leaders, if their conditions are met. Therefore this implementation ensures\n    // stabilty, becauseeven if a Follwer (or Leader) wasn\'t prepared it ensures every agent is on\n    // the same page.\n    // HACK: if (state.role == FOLLOWER)\n    {\n      state.color = state.leader == null ? context.globals()["colorUnkown"] : context.globals()["colorFollower"];\n      // if timout is not expired\n      if (state.wait > 0) {\n        //  Follower Phase 2 - PREPARE\n        state.height = state.leader == null ? context.globals()["phase0Height"] : context.globals()["phase1Height"];\n        // 21: wait for messages of the form (leaderP repare, v, globalRound) for the time of timeoutp\n        let leaderPrepareMessages = allCurrentMessages.filter(m => {\n          let typeCheck = m.type == LeaderPrepare;\n          let globalRoundCheck = m.data.globalRound >= state.globalRound;\n          return typeCheck && globalRoundCheck;\n        });\n        // if recieved at least one message then\n        if (leaderPrepareMessages.length > 0) {\n          let leaderMessage = leaderPrepareMessages[0];\n          state.leader = leaderMessage.data.frm;\n          // temporaryDecided  v\n          state.temporaryDecided = leaderMessage.data.value;\n          // send (followerPrepare, true, globalRound) back to Leader process\n          SendTo(state, context, FollowerPrepare, true, state.leader);\n          state.wait = state.timeout + 1;\n          state.prepared = true;\n        }\n\n        if (state.prepared) {\n          state.height = context.globals()["phase2Height"];\n        }\n\n        //  Follower Phase 3 - ACKOWLEDGE\n        // wait for messages of the form (leaderAcknowledge, x, globalRound) for the time of timeoutp\n        let leaderAcknowledgeMessages = allCurrentMessages.filter(m => {\n          let typeCheck = m.type == LeaderAcknowledge;\n          let globalRoundCheck = m.data.globalRound >= state.globalRound;\n          return typeCheck && globalRoundCheck;\n        });\n        // if recieved at least one message then\n        if (leaderAcknowledgeMessages.length > 0) {\n          state.height = context.globals()["phase3Height"];\n          let leaderMessage = leaderAcknowledgeMessages[0];\n          // decided  temporaryDecided\n          let decisionValue = state.temporaryDecided\n          let globalRound = leaderMessage.data.globalRound;\n          state.leader = leaderMessage.data.frm;\n          // decidedp  x\n          state.decided = decisionValue;\n          // decidedListp[globalRound]  decidedp\n          state.decidedList[globalRound] = decisionValue;\n          // send (followerAcknowledge, true, globalRound) back to Leader process\n          SendTo(state, context, FollowerAcknowledge, true, state.leader);\n          if (state.xValueList.length == state.decidedList.length) {\n            // return decidedListp\n            state.addMessage("gamemaster", "decided", {\n              "frm": state.agent_name,\n              "decidedList": state.decidedList,\n              "role": FOLLOWER\n            });\n            state.role = PHASEFINISH;\n          }\n          // init new globalRound\n          state.globalRound = globalRound + 1;\n          state.wait = state.timeout + 1;\n          state.prepared = false;\n        }\n      }\n\n      // if timeout is expired\n      // else role  Candidate\n      else if (state.role != LEADER) {\n        state.role = CANDIDATE;\n        state.wait = 0;\n      }\n    }\n\n    // PHASE 1 - ELECTION PHASE (Candidate)\n    //  Leader Phase 1\n    if (state.role == CANDIDATE) {\n      state.color = context.globals()["colorCandidateProposer"];\n      if (state.wait < 1) {\n        // send (leaderRequest, globalRound) to all processes\n        Send(state, context, LeaderRequest, state.agent_name);\n        state.voteMessages = [];\n        state.leader = null;\n        state.wait = state.timeout;\n        //state.role = FOLLOWER;\n      } else {\n\n        // wait for messages of the form (leaderP repare, globalRound) for the time of timeoutp\n        let voteMessages = allCurrentMessages.filter(m => m.type == FollowerResponse && m.data.value);\n        state.voteMessages = state.voteMessages.concat(voteMessages);\n        // if recieved more than k/2 messages with (f ollowerResponse, true, globalRound) then\n        if (state.voteMessages.length + 1 > (n / 2)) {\n          // role  Leader\n          state.role = LEADER;\n          state.leader = state.agent_name;\n          state.wait = null; // To know, if entering a wait funciton for the first time\n        }\n      }\n    }\n\n    // LEADER\n    if (state.role == LEADER) {\n      // update view\n      state.color = context.globals()["colorLeader"];\n\n      // wait for messages of the form (f ollowerP repare, , globalRound) for the time of timeoutp\n      let newPreparedMsgs = allCurrentMessages.filter(m => m.type == FollowerPrepare && m.data.globalRound == state.globalRound);\n      state.preparedMsgs = state.preparedMsgs.concat(newPreparedMsgs);\n      let preparedMsgs = state.preparedMsgs;\n\n      // wait for messages of the form (f ollowerAcknowledge, , globalRound) for the time of timeoutp\n      let newAcknowledgedMsgs = allCurrentMessages.filter(m => m.type == FollowerAcknowledge && m.data.globalRound == state.globalRound);\n      state.acknowledgedMsgs = state.acknowledgedMsgs.concat(newAcknowledgedMsgs);\n      let acknowledgedMsgs = state.acknowledgedMsgs;\n\n      // If not all decisions made\n      if (state.decidedList.length < state.xValueList.length) {\n        // 2 PHASE COMMIT\n\n        // x is wanted decisionValue\n        let x = state.xValueList[state.globalRound];\n        // temporaryDecidedp  x\n        state.temporaryDecided = x;\n\n\n        //  Leader Phase 2 - PREPARE\n        if (preparedMsgs.length + 1 < n / 2) {\n          if (state.prepared == null && preparedMsgs.length == 0 || state.wait < 0) {\n            state.prepared = true;\n            // send (leaderPrepare, globalRound) to all processes\n            Send(state, context, LeaderPrepare, x);\n            state.wait = state.timeout;\n            state.preparedMsgs = [];\n          }\n        }\n\n        // if recieved more than k/2 messages with (f ollowerP repare, true, globalRound) then\n        else {\n          //  Leader Phase 3  - ACKNOwLEDGE\n\n          // decided  temporaryDecidedp, decidedListp[globalRound]  decidedp\n          state.decided = state.temporaryDecided;\n          state.decidedList[state.globalRound] = state.temporaryDecided;\n\n          // If less than n/2 acknowledged messages recieved\n          if (acknowledgedMsgs.length + 1 < n / 2) {\n\n            if (state.ackknowledge == null && acknowledgedMsgs.length == 0 || state.wait < 0) {\n\n\n              state.ackknowledge = true;\n              // send (leaderAcknowledge, x, globalRound) to all processes\n              Send(state, context, LeaderAcknowledge, x);\n              state.wait = state.timeout;\n              state.acknowledgedMsgs = [];\n            }\n          }\n          // if recieved more than k/2 messages with (followerAcknowledge, true, globalRound) then\n          else {\n\n\n            // inite next global round\n            state.globalRound++;\n            state.prepared = null;\n            state.ackknowledge = null;\n            state.preparedMsgs = [];\n            state.acknowledgedMsgs = [];\n\n            // If leader should change after one decision (forced 3PC instead of 2PC)\n            if (context.globals()["leaderDecidesOnlyOneValue"]) {\n              state.role = FOLLOWER\n              // optional : if timoutChangeAfterLeaderDecided > 0 the probabilty of a leaderchange is being favored\n              if (context.globals()["timoutChangeAfterLeaderDecided"] != null) {\n                state.wait = state.timeout + context.globals()["timoutChangeAfterLeaderDecided"];\n              } else {\n                state.wait = state.timeout;\n              }\n            } else {\n              state.wait = state.timeout;\n            }\n\n          }\n        }\n      }\n\n      // Finished all decisions\n      if (state.decidedList.length == state.xValueList.length) {\n        if (state.xValueList.length == state.decidedList.length) {\n          // return decidedListp\n          state.addMessage("gamemaster", "decided", {\n            "frm": state.agent_name,\n            "decidedList": state.decidedList,\n            "role": LEADER\n          });\n          state.role = PHASEFINISH;\n          state.height = context.globals()["phase3Height"];;\n        }\n      }\n\n    }\n  }\n};\n\n/**\n * Sends a message to all agents\n * \n * @param {string} R kind of message\n * @param {AgentState} state of the agent\n */\nfunction Send(state, context, type, value) {\n  const n = context.globals()["numberOfAgents"];\n  for (let reciever = 0; reciever < n; reciever++) {\n    if (reciever != state.agent_name) {\n      SendTo(state, context, type, value, reciever);\n    }\n  }\n};\n\n\n/**\n * Sends a message to specific agent\n */\nfunction SendTo(state, context, type, value, reciever) {\n  let msg = getMessage(state, type, value, reciever);\n  let messageAgent = stdlib.getMessageAgent(state, msg, reciever);\n  state.addMessage("hash", "create_agent", messageAgent);\n}\n\nfunction getMessage(state, type, value, reciever) {\n  let msg = {\n    to: reciever,\n    type: type,\n    data: {\n      frm: state.agent_name,\n      value: value,\n      globalRound: state.globalRound,\n      type: type\n    },\n  };\n  return msg;\n}',
        ref: "1.0",
      },
      {
        name: "Multi_Raft_Node.js.json",
        path: "src/behaviors/Multi_Raft_Node.js.json",
        contents:
          '{\n\t"keys": {\n\t\t"allMessages": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"dieTimer": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"leader": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"phase": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"voteMessages": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"heartBeatMessages": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"wait": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"timeout": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"decidedList": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"globalRound": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"preparedMsgs": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"acknoledgedMsgs": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"xValueList": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"prepare": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"ackknowledge": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"waitAck": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"heartBeat": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"round": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"deathRound": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"conditions": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t},\n\t\t"decided": {\n\t\t\t"type": "any",\n\t\t\t"nullable": true\n\t\t}\n\t},\n\t"built_in_key_use": null,\n\t"dynamic_access": false\n}',
        ref: "1.0",
      },
      {
        name: "Timeout_Node.js",
        path: "src/behaviors/Timeout_Node.js",
        contents:
          '/**\n * @param {AgentState} state of the agent\n * @param {AgentContext} context of the agent\n */\nconst behavior = (state, context) => {\n  let allMessages = context.messages();\n  let heightMessages = allMessages.filter(m => m.type = "height")\n  if (heightMessages.length > 0) {\n    state.timeout = heightMessages[0].data.value;\n    state.height = heightMessages[0].data.value * context.globals()["objectsMaxHeight"] / state.maxTimeout;\n  }\n};\n',
        ref: "1.0",
      },
      {
        name: "Timeout_Node.js.json",
        path: "src/behaviors/Timeout_Node.js.json",
        contents:
          '{\n\t"keys": {},\n\t"built_in_key_use": null,\n\t"dynamic_access": false\n}',
        ref: "1.0",
      },
      {
        name: "hash.json",
        path: "hash.json",
        contents:
          '{\n  "keywords": [],\n  "type": "Simulation"\n}',
        ref: "1.0",
      },
    ],
  },
];

export const BUILTIN_SIMULATIONS: SimulationProjectWithHcFiles[] =
  remoteSimulationProjects.map((project) => ({
    ...project,
    config: toHcConfig(project),
    files: toHcFiles(project),
    ref: project.ref ?? "main",
    access: null,
  }));
